# 第一期 | Linux 性能优化实战 by 倪朋飞

>  第 1 阶段(CPU 性能篇)

## 目录

1. [02 | 基础篇：到底应该怎么理解“平均负载”？](#02)
2. [03/04 | 基础篇：经常说的 CPU 上下文切换是什么意思？](#03/04)
3. [05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？](#05)



## <a name = '02'>02 | 基础篇：到底应该怎么理解“平均负载”？</a>

文章中涉及到的命令：
- uptime、w、top、htop：负载相关命令
- grep 'model name' /proc/cpuinfo | wc -l ：查看逻辑 cpu 数量
- lscpu：查看 cpu 信息
- stress/stress-ng： Linux 系统压力测试工具
- mpstat：是一个常用的多核 CPU 性能分析工具
- pidstat：是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标
- lsof



### 什么是平均负载？

> 平均负载是指**单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。**

可运行状态的进程，是指正在使用 CPU 或者等待 CPU 的进程，使用 ps 命令看到的处于 R 状态的进程。

不可中断状态的进程，是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应。ps 命令中看到的 D 状态的进程。



#### 查看平均负载

可以使用 uptime、w、top 命令

```sh
$ uptime
 13:42:55 up  8:50,  0 users,  load average: 0.00, 0.00, 0.00
```

uptime 命令各字段的含义：
- 当前时间
- 系统运行时间
- 登录的用户数
- **1 分钟的平均负载**
- **5 分钟的平均负载**
- **15 分钟的平均负载**

` uptime 中平均负载有三个数值，这三个不同时间内的平均负载值可以反映系统平均负载的一个趋势，依据这个趋势做相应的操作。`



ps 命令中进程的状态：

- D，不可中断的睡眠状态（通常是 IO）
- R，运行中或者可运行状态
- S，可中断的睡眠状态（等待事件去完成）
- T，被任务控制信号挂起的的状态
- t，追踪过程中被调试器挂起的状态
- W，已废弃
- X，退出状态（永远不会被看到）
- Z，停止了但是没有被父进程回收的僵尸进程

![image-20200526212425130](imgs/process-state-in-ps.png)



### 平均负载为多少合适？

`平均负载最理想的情况是等于 CPU 个数。`

逻辑 CPU 核心数 = 物理 CPU 数 *  每颗 CPU 核心数 * 每个核心的超线程数

1. 查看逻辑 CPU 核心数

```sh
$ grep 'model name' /proc/cpuinfo | wc -l
4

## 或者
$ lscpu
...
```

#### 对于实际生产环境中，当平均负载高于 CPU 数量 70% 的时候，应该分析排查负载高的问题了。
>  （比如，机器的逻辑 CPU 数量为 4，当平均负载大于 2.8 的时候，就应该着手开始排查了。）

不过，更应该做的是，监控平均负载，根据历史数据，判断负载的变化趋势，当负载有明显的升高时，再去做分析和调查。



### 平均负载和 CPU 使用率的关系

CPU 使用率：单位时间内 CPU 繁忙情况的统计。与平均负载不一定完全对应。

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。



### 平均负载案例分析

前期准备：

``` sh
$ apt install stress stree-ng sysstat
```

#### 场景一：CPU 密集型

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 模拟一个 CPU 使用率 100% 的场景
$ stress --cpu 1 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有的 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```


#### 场景二：I/O 密集型进程

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 模拟 I/O 压力
$ stress -i 1 --timeout 600   # 此命令可能模拟不出来
$ stress-ng -i 1 --hdd 1 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```

#### 场景三：大量进程的场景

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。
# 模拟 8 个进程
$ stress -c 8 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```



### 发现专栏精选留言

> @shellmode:
>
> 在 sched/loadavg.c 中计算平均值的算法为EMA，这种算法的目的主要是“距离目标预测窗口越近，则数据的价值越高，对未来影响越大”
>
> 如果说“更快的计算”应该只有里面的 fixed_power_int 函数用 O(log n) 的时间来算 x^n
>
> 所以内核中用 EMA 来算 loadavg 本质上并不是增加计算性能，而是让 loadavg 的趋势化更明显



### 补充


解决 docker 中 ubuntu 系统 man 命令 "No manual entry for X" 的方法：

https://github.com/tianon/docker-brew-ubuntu-core/issues/122#issuecomment-380529430



## <a name = '03/04'>03/04 | 基础篇：经常说的 CPU 上下文切换是什么意思？</a>

Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器。

CPU 在运行任何任务前，必须依赖寄存器和程序计数器，这些依赖的资源称为 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

**系统运行的任务包括进程、线程和中断。**根据任务的不同，CPU 上下文切换可以分为进程上下文切换、线程上下文切换和中断上下文切换。

1. 进程上下文切换

    Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间。

    - 内核空间：最高权限，可以直接访问所有资源；
    - 用户空间：访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

    进程既可以在内核空间运行，又可以在用户空间运行。从用户态到内核态的转变，需要系统调用来完成。

    系统调用过程：CPU 寄存器用户态中的指令地址，需要先保存下来，然后，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后跳到内核态执行内核任务。系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

    系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源。所以，**系统调用过程通常称为特权模式切换，而不是上下文切换。**
    - 进程上下文切换，是指从一个进程切换到另一个进程运行。
    - 而系统调用过程中一直是同一个进程在运行。

    **进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。**

    进程调度时，才会切换上下文。Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。

    - 公平调度，时间片轮转
    - 系统资源不足时，进程挂起
    - 进程主动 sleep
    - 有更高优先级的进程运行时
    - 硬件中断

2. 线程上下文切换

    进程是资源拥有的基本单位。

    线程是调度的基本单位，线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。

    线程切换可分为：
    - 两个线程属于不同进程，因为资源不共享，所以等同于进程切换。
    - 楞个线程属于相同进程，**只需要切换线程的私有数据、寄存器等不共享的数据。**

3. 中断上下文切换

    为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序，响应设备事件。中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

#### 案例分析

涉及到的命令：

	1. vmstat 5 系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

 	2. pidstat -w 5 可以查看每个进程上下文切换的情况。
 	3. sysbench 模拟系统多线程调度切换的情况。
 	4. /proc 是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。

vmstat 示例

``` sh
# 每隔5秒输出1组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 102504 315972 850352    0    0    16    37    0    2  1  1 98  1  0

# cs（context switch）是每秒上下文切换的次数。
# in（interrupt）则是每秒中断的次数。
# r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
# b（Blocked）则是处于不可中断睡眠状态的进程数。
```

pidstat 示例

``` sh
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0-70-generic (VM-255-120-ubuntu)     05/31/20        _x86_64_        (1 CPU)

13:29:45      UID       PID   cswch/s nvcswch/s  Command
13:29:50        0         7      1.21      0.00  ksoftirqd/0
13:29:50        0         8     48.79      0.00  rcu_sched
13:29:50        0        11      0.20      0.00  watchdog/0
13:29:50        0       164      1.21      0.00  kworker/0:1H
13:29:50        0       322      0.60      0.20  jbd2/vda1-8
13:29:50        0      1082      1.01      0.00  php-fpm7.2
13:29:50      113      1246     10.08      0.20  redis-server
13:29:50        0      8635      0.20      0.00  barad_agent
13:29:50        0      8636      1.41      0.20  barad_agent
13:29:50        0     21898      2.22      0.00  kworker/0:0
13:29:50        0     23816      9.07      0.00  kworker/u2:0
13:29:50        0     27062      1.21      0.00  YDLive
13:29:50        0     27981      0.40      0.00  YDService
13:29:50        0     29043      6.85      0.00  kworker/u2:3
13:29:50      500     32137      0.20      0.20  pidstat

# cswch 每秒自愿上下文交换次数。所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
# nvcswch 每秒非自愿上下文切换次数。而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
```



实验过程：

```sh
# 间隔1秒后输出1组数据
$ vmstat 1 1

# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run

# 每隔1秒输出1组数据（需要Ctrl+C才结束）
$ vmstat 1

# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
$ pidstat -w -u 1
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -wt 1

# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
$ watch -d 'cat /proc/interrupts | sort -nr -k 2 '
```



1. 每秒上下文切换多少次合适？
    	取决于 CPU 性能，如果系统的上下文次数比较稳定，那么从数百到一万以内，都是正常的。但当次数超过一万时，或者切换次数出现指数增长的时候，很可能出现性能问题了。此时，还需要根据上下文切换的类型，做具体分析。

   - 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
   - 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
   - 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。


## <a name = '05'>05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？</a>

### CPU 使用率

CPU 使用率是单位时间内 CPU 使用情况的统计，以百分比的方式展示，是最常用也是最熟悉的 CPU 指标。

节拍率（内核中表示为 HZ）：每秒触发时间中断的次数。

```sh
# 查看节拍率
$ grep 'CONFIG_HZ=' /boot/config-$(uname -r)
CONFIG_HZ=1000
```

在我的系统中，节拍率被设置成了 1000， 表示每秒触发 1000 次时间中断。节拍率是内核选项，用户不能直接访问。因此，内核提供了一个用户节拍率，它的值固定为 100。

通过 /proc 虚拟文件系统可以查看系统内部状态信息。

``` sh
# 只保留各个CPU的数据
$ cat /proc/stat | grep ^cpu
cpu  1700286 825 167257 601777927 9809 0 3234 0 0 0
cpu0 401326 218 34540 150509513 1701 0 680 0 0 0
cpu1 454424 187 55370 150374417 2842 0 1287 0 0 0
cpu2 434167 207 47479 150403282 3283 0 742 0 0 0
cpu3 410368 211 29867 150490713 1982 0 523 0 0 0
```

第一列表示的是 CPU 编号，第一行没有编号的 cpu ，表示的是所有 CPU 的累加。其他列的含义可以通过 man proc 查看。

以下是常见的CPU 使用率相关的指标：

- user（通常缩写为 us），代表用户态 CPU 时间。不包括nice，但是包括 guest。
- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间
- system（通常缩写为 sys），代表内核态 CPU 时间。
- idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
- softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。

**CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比**，用公式来表示就是：

$$CPU 使用率 = 1 - \frac{空闲时间}{总 CPU 时间}$$

/proc/stat 记录的是开机以来的数据，不能代表当前的状态，没有参考价值。一般情况下，可以去某段时间的差值求取平均 CPU 使用率：

$$CPU 使用率 = 1 - \frac{空闲时间_{new} - 空闲时间_{old}}{总 CPU 时间_{new} - 总 CPU 时间_{old}}$$

### 怎么查看 CPU 使用率

- top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。
- ps 则只显示了每个进程的资源使用情况。

```sh
$ top
top - 23:35:18 up 17 days, 11:48,  3 users,  load average: 0.00, 0.01, 0.05
Tasks: 126 total,   1 running, 125 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8010576 total,  2643456 free,   824480 used,  4542640 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  6855140 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
18481 root      20   0  162128   2236   1540 R   6.2  0.0   0:00.01 top
    1 root      20   0  191108   3964   2448 S   0.0  0.0   0:19.27 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.26 kthreadd
    3 root      20   0       0      0      0 S   0.0  0.0   0:02.60 ksoftirqd/0
    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
    7 root      rt   0       0      0      0 S   0.0  0.0   0:00.33 migration/0
    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh
```

top 默认每隔三秒刷新一次，显示的是所有 CPU 的平均值，这个时候你只需要按下数字 1 ，就可以切换到每个 CPU 的使用率了。

top 命令没有细分用户态 CPU 和内核态 CPU；可以使用 pidstat 查看每个进程的详细情况。

```sh
$ pidstat 1 5
Linux 3.10.0-693.el7.x86_64 (localhost.localdomain)     2020年06月28日  _x86_64_        (4 CPU)

23时38分48秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
23时38分49秒     0     18495    0.99    0.99    0.00    1.98     0  pidstat

23时38分49秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
23时38分50秒     0     18495    0.00    1.00    0.00    1.00     0  pidstat

...

平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
平均时间:    27     17617    0.20    0.00    0.00    0.20     -  mysqld
平均时间:     0     18495    0.40    1.00    0.00    1.40     -  pidstat
平均时间:     0     29799    0.20    0.00    0.00    0.20     -  vmtoolsd

```



### CPU 使用率过高怎么办？

GDB 调试程序的过程会中断程序运行，这在线上环境往往是不允许的。GDB 只适合用在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。

perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。

perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数。

```sh
$ perf top
Samples: 4K of event 'cpu-clock', 4000 Hz, Event count (approx.): 777304510 lost: 0/0 drop: 0/0
Overhead  Shared Object       Symbol
  11.82%  perf                [.] __symbols__insert
   3.96%  perf                [.] rb_next
   3.10%  libc-2.17.so        [.] __GI_____strtoull_l_internal
   2.91%  [kernel]            [k] module_get_kallsym
   2.68%  [kernel]            [k] number.isra.2
```

第一行包括：采样数、事件类型、节拍率、事件总数（不同的Linux 发行版数据有所不同）

第二行的数据包含四列：

- Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。
- Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
- Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
- Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。

perf record 提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。使用时加上 -g 参数，开启调用关系的采样。

### 案例

使用 docker 部署 nginx 和 php 服务，ab 命令进行 http 压力测试。

```sh
# -g开启调用关系分析，-p指定php-fpm的进程号21650
$ perf top -g -p 21650
+   23.87%     0.00%  [unknown]           [.] 0x6cb6258d4c544155                                                      ◆
+   23.87%     0.00%  libc-2.24.so        [.] 0x00007f08f84f72e1                                                      ▒
+   23.84%     0.00%  php-fpm             [.] 0x000055fee4396642                                                      ▒
-   23.83%     0.00%  php-fpm             [.] 0x000055fee41476fc                                                      ▒
     0x55fee41476fc                                                                                                   ▒
     0x55fee41f6f94                                                                                                   ▒
   + 0x55fee428e323                                                                                                   ▒
+   23.83%     0.00%  php-fpm             [.] 0x000055fee41f6f94                                                      ▒
+   23.83%     0.00%  php-fpm             [.] 0x000055fee428e323                                                      ▒
+   22.27%     0.00%  php-fpm             [.] 0x000055fee428d96e
```

centos 7 下 perf top 无法定位到具体的函数，会只显示十六进制的地址，需要使用 perf record 将记录保存下来，再到容器内部查看结果。

```sh
$ perf record -g -p 21699
$ docker cp perf.data phpfpm:/tmp
$ docker exec -i -t phpfpm bash
$ cd /tmp/
$ apt-get update && apt-get install -y linux-perf linux-tools procps
+   99.95%     0.00%  php-fpm  libc-2.24.so                [.] __libc_start_main                                      ▒
+   99.95%     0.00%  php-fpm  [unknown]                   [k] 0x6cb6258d4c544155                                     ▒
+   99.84%     0.00%  php-fpm  php-fpm                     [.] 0xffffaa011d000642                                     ▒
+   99.83%     0.00%  php-fpm  php-fpm                     [.] php_execute_script                                     ▒
+   99.82%     0.00%  php-fpm  php-fpm                     [.] zend_execute_scripts                                   ▒
+   99.82%     0.00%  php-fpm  php-fpm                     [.] zend_execute                                           ▒
+   96.64%     4.39%  php-fpm  php-fpm                     [.] execute_ex                                             ▒
+   23.33%     0.00%  php-fpm  php-fpm                     [.] 0xffffaa011cef9a7c                                     ▒
+   18.52%     0.00%  php-fpm  php-fpm                     [.] 0xffffaa011cfc2ea3                                     ▒
+    6.34%     6.31%  php-fpm  libm-2.24.so                [.] sqrt                                                   ▒
+    6.01%     5.98%  php-fpm  php-fpm                     [.] add_function   
```

