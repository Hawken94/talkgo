# 第一期 | Linux 性能优化实战 by 倪朋飞

>  第 1 阶段(CPU 性能篇)

## 目录

1. [02 | 基础篇：到底应该怎么理解“平均负载”？](#02)
2. [03/04 | 基础篇：经常说的 CPU 上下文切换是什么意思？](#03/04)



## <a name = '02'>02 | 基础篇：到底应该怎么理解“平均负载”？</a>

文章中涉及到的命令：
- uptime、w、top、htop：负载相关命令
- grep 'model name' /proc/cpuinfo | wc -l ：查看逻辑 cpu 数量
- lscpu：查看 cpu 信息
- stress/stress-ng： Linux 系统压力测试工具
- mpstat：是一个常用的多核 CPU 性能分析工具
- pidstat：是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标
- lsof



### 什么是平均负载？

> 平均负载是指**单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。**

可运行状态的进程，是指正在使用 CPU 或者等待 CPU 的进程，使用 ps 命令看到的处于 R 状态的进程。

不可中断状态的进程，是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应。ps 命令中看到的 D 状态的进程。



#### 查看平均负载

可以使用 uptime、w、top 命令

```sh
$ uptime
 13:42:55 up  8:50,  0 users,  load average: 0.00, 0.00, 0.00
```

uptime 命令各字段的含义：
- 当前时间
- 系统运行时间
- 登录的用户数
- **1 分钟的平均负载**
- **5 分钟的平均负载**
- **15 分钟的平均负载**

` uptime 中平均负载有三个数值，这三个不同时间内的平均负载值可以反映系统平均负载的一个趋势，依据这个趋势做相应的操作。`



ps 命令中进程的状态：

- D，不可中断的睡眠状态（通常是 IO）
- R，运行中或者可运行状态
- S，可中断的睡眠状态（等待事件去完成）
- T，被任务控制信号挂起的的状态
- t，追踪过程中被调试器挂起的状态
- W，已废弃
- X，退出状态（永远不会被看到）
- Z，停止了但是没有被父进程回收的僵尸进程

![image-20200526212425130](imgs/process-state-in-ps.png)



### 平均负载为多少合适？

`平均负载最理想的情况是等于 CPU 个数。`

逻辑 CPU 核心数 = 物理 CPU 数 *  每颗 CPU 核心数 * 每个核心的超线程数

1. 查看逻辑 CPU 核心数

```sh
$ grep 'model name' /proc/cpuinfo | wc -l
4

## 或者
$ lscpu
...
```

#### 对于实际生产环境中，当平均负载高于 CPU 数量 70% 的时候，应该分析排查负载高的问题了。
>  （比如，机器的逻辑 CPU 数量为 4，当平均负载大于 2.8 的时候，就应该着手开始排查了。）

不过，更应该做的是，监控平均负载，根据历史数据，判断负载的变化趋势，当负载有明显的升高时，再去做分析和调查。



### 平均负载和 CPU 使用率的关系

CPU 使用率：单位时间内 CPU 繁忙情况的统计。与平均负载不一定完全对应。

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。



### 平均负载案例分析

前期准备：

``` sh
$ apt install stress stree-ng sysstat
```

#### 场景一：CPU 密集型

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 模拟一个 CPU 使用率 100% 的场景
$ stress --cpu 1 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有的 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```


#### 场景二：I/O 密集型进程

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 模拟 I/O 压力
$ stress -i 1 --timeout 600   # 此命令可能模拟不出来
$ stress-ng -i 1 --hdd 1 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```

#### 场景三：大量进程的场景

``` sh
# 在三个窗口中执行以下命令

$ uptime
# 当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。
# 模拟 8 个进程
$ stress -c 8 --timeout 600
# 监控 uptime
$ watch -d uptime
# 监控所有 CPU 的使用率情况
$ mpstat -P ALL 5
# 查询进程 CPU、wait 占用情况
$ pidstat -u 5 1
```



### 发现专栏精选留言

> @shellmode:
>
> 在 sched/loadavg.c 中计算平均值的算法为EMA，这种算法的目的主要是“距离目标预测窗口越近，则数据的价值越高，对未来影响越大”
>
> 如果说“更快的计算”应该只有里面的 fixed_power_int 函数用 O(log n) 的时间来算 x^n
>
> 所以内核中用 EMA 来算 loadavg 本质上并不是增加计算性能，而是让 loadavg 的趋势化更明显



### 补充


解决 docker 中 ubuntu 系统 man 命令 "No manual entry for X" 的方法：

https://github.com/tianon/docker-brew-ubuntu-core/issues/122#issuecomment-380529430



## <a name = '03/04'>03/04 | 基础篇：经常说的 CPU 上下文切换是什么意思？</a>

Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器。

CPU 在运行任何任务前，必须依赖寄存器和程序计数器，这些依赖的资源称为 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

**系统运行的任务包括进程、线程和中断。**根据任务的不同，CPU 上下文切换可以分为进程上下文切换、线程上下文切换和中断上下文切换。

1. 进程上下文切换

    Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间。

    - 内核空间：最高权限，可以直接访问所有资源；
    - 用户空间：访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

    进程既可以在内核空间运行，又可以在用户空间运行。从用户态到内核态的转变，需要系统调用来完成。

    系统调用过程：CPU 寄存器用户态中的指令地址，需要先保存下来，然后，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后跳到内核态执行内核任务。系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

    系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源。所以，**系统调用过程通常称为特权模式切换，而不是上下文切换。**
    - 进程上下文切换，是指从一个进程切换到另一个进程运行。
    - 而系统调用过程中一直是同一个进程在运行。

    **进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。**

    进程调度时，才会切换上下文。Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。

    - 公平调度，时间片轮转
    - 系统资源不足时，进程挂起
    - 进程主动 sleep
    - 有更高优先级的进程运行时
    - 硬件中断

2. 线程上下文切换

    进程是资源拥有的基本单位。

    线程是调度的基本单位，线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。

    线程切换可分为：
    - 两个线程属于不同进程，因为资源不共享，所以等同于进程切换。
    - 楞个线程属于相同进程，**只需要切换线程的私有数据、寄存器等不共享的数据。**

3. 中断上下文切换

    为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序，响应设备事件。中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

#### 案例分析

涉及到的命令：

	1. vmstat 5 系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

 	2. pidstat -w 5 可以查看每个进程上下文切换的情况。
 	3. sysbench 模拟系统多线程调度切换的情况。
 	4. /proc 是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。

vmstat 示例

``` sh
# 每隔5秒输出1组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 102504 315972 850352    0    0    16    37    0    2  1  1 98  1  0
 
# cs（context switch）是每秒上下文切换的次数。
# in（interrupt）则是每秒中断的次数。
# r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
# b（Blocked）则是处于不可中断睡眠状态的进程数。
```

pidstat 示例

``` sh
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0-70-generic (VM-255-120-ubuntu)     05/31/20        _x86_64_        (1 CPU)

13:29:45      UID       PID   cswch/s nvcswch/s  Command
13:29:50        0         7      1.21      0.00  ksoftirqd/0
13:29:50        0         8     48.79      0.00  rcu_sched
13:29:50        0        11      0.20      0.00  watchdog/0
13:29:50        0       164      1.21      0.00  kworker/0:1H
13:29:50        0       322      0.60      0.20  jbd2/vda1-8
13:29:50        0      1082      1.01      0.00  php-fpm7.2
13:29:50      113      1246     10.08      0.20  redis-server
13:29:50        0      8635      0.20      0.00  barad_agent
13:29:50        0      8636      1.41      0.20  barad_agent
13:29:50        0     21898      2.22      0.00  kworker/0:0
13:29:50        0     23816      9.07      0.00  kworker/u2:0
13:29:50        0     27062      1.21      0.00  YDLive
13:29:50        0     27981      0.40      0.00  YDService
13:29:50        0     29043      6.85      0.00  kworker/u2:3
13:29:50      500     32137      0.20      0.20  pidstat

# cswch 每秒自愿上下文交换次数。所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
# nvcswch 每秒非自愿上下文切换次数。而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
```



实验过程：

```sh
# 间隔1秒后输出1组数据
$ vmstat 1 1

# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run

# 每隔1秒输出1组数据（需要Ctrl+C才结束）
$ vmstat 1

# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
$ pidstat -w -u 1
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -wt 1

# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
$ watch -d 'cat /proc/interrupts | sort -nr -k 2 '
```



1. 每秒上下文切换多少次合适？
    	取决于 CPU 性能，如果系统的上下文次数比较稳定，那么从数百到一万以内，都是正常的。但当次数超过一万时，或者切换次数出现指数增长的时候，很可能出现性能问题了。此时，还需要根据上下文切换的类型，做具体分析。

   - 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
   - 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
   - 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

